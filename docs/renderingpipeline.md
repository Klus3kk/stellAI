# Rendering Pipeline in ClueEngine

## Overview

The **ClueEngine** rendering pipeline is responsible for rendering 3D objects and their corresponding materials to the screen. The pipeline handles everything from the creation of objects and the setup of their properties (like shaders, textures, and transformations) to rendering them in the right order with proper lighting, shading, and post-processing effects. The rendering is powered by **OpenGL**, and the pipeline integrates vertex and fragment shaders to efficiently display the 3D scene.

## Key Components

The rendering pipeline consists of the following components:

1. **Shaders**
2. **Textures and Materials**
3. **Lighting**
4. **Object Transformation**
5. **Camera and Projection**
6. **Frame Buffer and Post-Processing**

### 1. **Shaders**

Shaders are programs that run on the GPU and control how the geometry and pixels are processed. **ClueEngine** uses two main types of shaders:

- **Vertex Shaders**: These shaders transform the vertices of the 3D models from model space to screen space. The vertex shader is responsible for manipulating the positions of the vertices and passing other data (e.g., normals, texture coordinates) to the fragment shader.
  
- **Fragment Shaders**: These shaders process fragments (or pixels) that are generated by the rasterization of the vertices. The fragment shader calculates the final color of each pixel, taking into account textures, lighting, and material properties.

#### Shader Compilation and Linking

Shaders are written in **GLSL** and are compiled and linked at runtime. **ClueEngine** uses custom C functions to load, compile, and link the shaders. The shaders are then used to render objects with specific material properties (e.g., texture, lighting).

```c
unsigned int loadShader(const char* vertexPath, const char* fragmentPath) {
    // Load and compile shaders
    char* vShaderCode = readFile(vertexPath);
    char* fShaderCode = readFile(fragmentPath);
    unsigned int vertex = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertex, 1, &vShaderCode, NULL);
    glCompileShader(vertex);
    checkCompileErrors(vertex, "VERTEX");

    unsigned int fragment = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragment, 1, &fShaderCode, NULL);
    glCompileShader(fragment);
    checkCompileErrors(fragment, "FRAGMENT");

    // Link the shaders into a shader program
    unsigned int shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertex);
    glAttachShader(shaderProgram, fragment);
    glLinkProgram(shaderProgram);
    checkCompileErrors(shaderProgram, "PROGRAM");

    // Cleanup shaders after linking
    glDeleteShader(vertex);
    glDeleteShader(fragment);

    return shaderProgram;
}
```

### 2. **Textures and Materials**

Textures and materials are crucial for defining the surface appearance of objects. **ClueEngine** supports two main types of materials:

- **Basic Textures**: Textures are 2D images that are mapped onto 3D objects to define their appearance. They can represent various properties like diffuse color, normal maps, and specular maps.

- **PBR (Physically-Based Rendering) Materials**: These materials simulate realistic lighting and shading based on real-world physical properties. PBR materials use parameters like roughness, metallicity, and ambient occlusion to create lifelike materials that react realistically to different lighting conditions.

The engine uses the **SOIL2** library to load textures from image files, and the material properties are applied within the shaders.

### 3. **Lighting**

The lighting system in **ClueEngine** supports three types of lights:

- **Point Lights**: A light source that radiates in all directions from a single point.
- **Directional Lights**: A light source that emits parallel rays, simulating sunlight.
- **Spotlights**: A light source that emits light in a cone shape, which is useful for simulating flashlights or stage lights.

Lighting calculations are performed in the fragment shader, where the lighting contributions from each light source are calculated based on the material properties and the surface geometry of the object.

### 4. **Object Transformation**

Each object in the scene can undergo transformations such as translation (moving), rotation, and scaling. These transformations are applied to the object's vertices before rendering.

**ClueEngine** uses transformation matrices to handle object transformations:

- **Model Matrix**: A transformation matrix applied to the object's vertices to position, rotate, and scale them in world space.
- **View Matrix**: The camera's transformation matrix that transforms world coordinates into camera space.
- **Projection Matrix**: A matrix that converts 3D coordinates into 2D screen space, based on the camera's field of view and aspect ratio.

The combined transformation of the model, view, and projection matrices determines the final position of an object on the screen.

### 5. **Camera and Projection**

The camera system in **ClueEngine** uses a **first-person** camera model, allowing for navigation through the 3D scene. The camera's position, orientation, and projection settings are defined using matrices.

- **Camera Position and Orientation**: The position and direction the camera is looking at, which are manipulated via user input (keyboard and mouse).
- **Perspective Projection**: The projection matrix simulates the perspective view, where objects farther away appear smaller.

### 6. **Frame Buffer and Post-Processing**

After rendering the scene, **ClueEngine** may apply post-processing effects to enhance the visual quality. These effects can include bloom, depth of field, motion blur, or color grading.

The **frame buffer** is a memory buffer that holds the rendered image. The frame buffer is used to store the image, apply post-processing effects, and display the final result on the screen.

### Rendering Flow

Hereâ€™s a high-level flow of how the rendering pipeline works in **ClueEngine**:

1. **Load Shaders and Textures**: The required shaders and textures are loaded into memory at the start.
2. **Process Objects**: Each object in the scene is processed in the **main loop**, and its properties (like position, rotation, scale) are updated.
3. **Apply Transformations**: Transformations are applied to the objects using transformation matrices.
4. **Lighting Calculations**: Each light in the scene affects the objects according to their material properties.
5. **Render Objects**: Objects are rendered to the screen using shaders, textures, and lighting information.
6. **Post-Processing**: After all objects are rendered, post-processing effects are applied to enhance the final image.
7. **Display on Screen**: The processed image is displayed on the screen.

## Conclusion

The **ClueEngine** rendering pipeline is designed to efficiently render complex 3D scenes using modern techniques such as shaders, PBR materials, and lighting effects. The modular approach allows for easy extensions, enabling you to add custom shaders, materials, or even entirely new rendering techniques. With its focus on flexibility and performance, the engine provides a powerful foundation for building 3D applications and games.
